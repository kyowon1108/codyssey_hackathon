<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gaussian Splatting Viewer (WebGL)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        #progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="progress">Loading: 0%</div>
    <div id="info" style="display: none;">
        <strong>Gaussian Splatting Viewer</strong><br>
        Drag: Rotate<br>
        Scroll: Zoom
    </div>
    <canvas id="canvas"></canvas>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            antialias: false,
            alpha: false,
            depth: true,
            premultipliedAlpha: false
        });

        if (!gl) {
            document.getElementById('progress').textContent = 'WebGL2 not supported';
            throw new Error('WebGL2 not supported');
        }

        const progressDiv = document.getElementById('progress');
        const infoDiv = document.getElementById('info');

        // Vertex shader for Gaussian splatting
        const vertexShaderSource = `#version 300 es
        precision highp float;

        in vec3 position;
        in vec3 scale;
        in vec4 rotation;  // quaternion
        in vec4 color;

        uniform mat4 viewMatrix;
        uniform mat4 projectionMatrix;
        uniform vec2 viewport;

        out vec4 vColor;
        out vec2 vPosition;

        // Compute 2D covariance from 3D Gaussian parameters
        vec3 computeCov2D(vec3 worldPos, vec3 scale, vec4 quat) {
            // Build rotation matrix from quaternion
            float x = quat.x, y = quat.y, z = quat.z, w = quat.w;
            mat3 R = mat3(
                1.0 - 2.0 * (y*y + z*z), 2.0 * (x*y - w*z), 2.0 * (x*z + w*y),
                2.0 * (x*y + w*z), 1.0 - 2.0 * (x*x + z*z), 2.0 * (y*z - w*x),
                2.0 * (x*z - w*y), 2.0 * (y*z + w*x), 1.0 - 2.0 * (x*x + y*y)
            );

            // Build scale matrix
            mat3 S = mat3(
                scale.x, 0.0, 0.0,
                0.0, scale.y, 0.0,
                0.0, 0.0, scale.z
            );

            // 3D covariance = R * S * S^T * R^T
            mat3 M = R * S;
            mat3 Sigma = M * transpose(M);

            // Project to 2D using Jacobian
            vec4 camPos = viewMatrix * vec4(worldPos, 1.0);
            float focal = viewport.x * projectionMatrix[0][0] / 2.0;

            mat3 J = mat3(
                focal / camPos.z, 0.0, -(focal * camPos.x) / (camPos.z * camPos.z),
                0.0, focal / camPos.z, -(focal * camPos.y) / (camPos.z * camPos.z),
                0.0, 0.0, 0.0
            );

            mat3 T = J * mat3(viewMatrix);
            mat3 cov2D = T * Sigma * transpose(T);

            // Return upper triangle (symmetric matrix)
            return vec3(cov2D[0][0], cov2D[0][1], cov2D[1][1]);
        }

        void main() {
            vec4 camSpace = viewMatrix * vec4(position, 1.0);
            vec4 clipSpace = projectionMatrix * camSpace;
            gl_Position = clipSpace;

            // Compute 2D covariance for splat size
            vec3 cov2d = computeCov2D(position, scale, rotation);

            // Compute bounding quad size
            float det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;
            float sqrtDet = sqrt(max(0.0, det));
            float maxSize = 3.0 * sqrt(max(cov2d.x, cov2d.z)) * 2.0;

            gl_PointSize = min(maxSize, 4096.0);

            vColor = color;
            vPosition = vec2(0.0);  // Will be set in fragment shader
        }
        `;

        // Fragment shader for Gaussian evaluation
        const fragmentShaderSource = `#version 300 es
        precision highp float;

        in vec4 vColor;
        in vec2 vPosition;

        out vec4 fragColor;

        void main() {
            // Compute Gaussian falloff
            vec2 d = gl_PointCoord * 2.0 - 1.0;
            float power = -0.5 * dot(d, d);

            if (power < -4.0) discard;

            float alpha = exp(power);
            alpha *= vColor.a;

            if (alpha < 0.01) discard;

            fragColor = vec4(vColor.rgb * alpha, alpha);
        }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            throw new Error('Failed to link program');
        }

        gl.useProgram(program);

        // Get attribute and uniform locations
        const positionLoc = gl.getAttribLocation(program, 'position');
        const scaleLoc = gl.getAttribLocation(program, 'scale');
        const rotationLoc = gl.getAttribLocation(program, 'rotation');
        const colorLoc = gl.getAttribLocation(program, 'color');
        const viewMatrixLoc = gl.getUniformLocation(program, 'viewMatrix');
        const projectionMatrixLoc = gl.getUniformLocation(program, 'projectionMatrix');
        const viewportLoc = gl.getUniformLocation(program, 'viewport');

        // Camera setup
        let camera = {
            position: [0, 0, 5],
            target: [0, 0, 0],
            up: [0, 1, 0],
            fov: 75 * Math.PI / 180,
            near: 0.1,
            far: 1000
        };

        // Mouse controls
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let rotation = [0, 0];

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            rotation[0] += dy * 0.01;
            rotation[1] += dx * 0.01;

            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position[2] += e.deltaY * 0.01;
            camera.position[2] = Math.max(0.5, Math.min(100, camera.position[2]));
        });

        // Matrix operations
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);

            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        // Load and parse splat file
        let iterationCount = 'unknown';
        let gaussianCount = 0;

        fetch('SPLAT_URL_PLACEHOLDER')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load scene');
                iterationCount = response.headers.get('X-Iteration') || 'unknown';
                return response.arrayBuffer();
            })
            .then(data => {
                progressDiv.textContent = 'Processing...';

                const view = new DataView(data);
                gaussianCount = data.byteLength / 44;

                const positions = new Float32Array(gaussianCount * 3);
                const scales = new Float32Array(gaussianCount * 3);
                const rotations = new Float32Array(gaussianCount * 4);
                const colors = new Float32Array(gaussianCount * 4);

                for (let i = 0; i < gaussianCount; i++) {
                    const offset = i * 44;

                    // Position (12 bytes)
                    positions[i * 3] = view.getFloat32(offset, true);
                    positions[i * 3 + 1] = view.getFloat32(offset + 4, true);
                    positions[i * 3 + 2] = view.getFloat32(offset + 8, true);

                    // Scale (12 bytes)
                    scales[i * 3] = view.getFloat32(offset + 12, true);
                    scales[i * 3 + 1] = view.getFloat32(offset + 16, true);
                    scales[i * 3 + 2] = view.getFloat32(offset + 20, true);

                    // Color (4 bytes)
                    colors[i * 4] = view.getUint8(offset + 24) / 255;
                    colors[i * 4 + 1] = view.getUint8(offset + 25) / 255;
                    colors[i * 4 + 2] = view.getUint8(offset + 26) / 255;
                    colors[i * 4 + 3] = view.getUint8(offset + 27) / 255;

                    // Rotation quaternion (16 bytes)
                    rotations[i * 4] = view.getFloat32(offset + 28, true);
                    rotations[i * 4 + 1] = view.getFloat32(offset + 32, true);
                    rotations[i * 4 + 2] = view.getFloat32(offset + 36, true);
                    rotations[i * 4 + 3] = view.getFloat32(offset + 40, true);
                }

                // Create VAO and buffers
                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

                const scaleBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, scaleBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, scales, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(scaleLoc);
                gl.vertexAttribPointer(scaleLoc, 3, gl.FLOAT, false, 0, 0);

                const rotBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, rotBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, rotations, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(rotationLoc);
                gl.vertexAttribPointer(rotationLoc, 4, gl.FLOAT, false, 0, 0);

                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(colorLoc);
                gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

                progressDiv.style.display = 'none';
                infoDiv.innerHTML = `<strong>Gaussian Splatting Viewer (WebGL)</strong><br>
                    Iteration: ${parseInt(iterationCount).toLocaleString()}<br>
                    Gaussians: ${gaussianCount.toLocaleString()}<br>
                    Drag: Rotate | Scroll: Zoom`;
                infoDiv.style.display = 'block';

                // Rendering loop
                function render() {
                    const aspect = canvas.width / canvas.height;
                    const projMatrix = perspective(camera.fov, aspect, camera.near, camera.far);

                    // Apply rotation
                    const cos1 = Math.cos(rotation[0]), sin1 = Math.sin(rotation[0]);
                    const cos2 = Math.cos(rotation[1]), sin2 = Math.sin(rotation[1]);
                    const camPos = [
                        camera.position[2] * sin2,
                        camera.position[2] * sin1,
                        camera.position[2] * cos1 * cos2
                    ];

                    const viewMatrix = lookAt(camPos, camera.target, camera.up);

                    gl.viewport(0, 0, canvas.width, canvas.height);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    gl.enable(gl.BLEND);
                    gl.blendFuncSeparate(gl.ONE_MINUS_DST_ALPHA, gl.ONE, gl.ONE_MINUS_DST_ALPHA, gl.ONE);
                    gl.enable(gl.DEPTH_TEST);

                    gl.uniformMatrix4fv(viewMatrixLoc, false, viewMatrix);
                    gl.uniformMatrix4fv(projectionMatrixLoc, false, projMatrix);
                    gl.uniform2f(viewportLoc, canvas.width, canvas.height);

                    gl.drawArrays(gl.POINTS, 0, gaussianCount);

                    requestAnimationFrame(render);
                }

                // Handle resize
                function resize() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                window.addEventListener('resize', resize);
                resize();

                render();
            })
            .catch(error => {
                progressDiv.textContent = `Error: ${error.message}`;
                console.error('Error:', error);
            });
    </script>
</body>
</html>
