<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gaussian Splatting Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 18px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 1000;
            max-width: 280px;
        }
        #progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1000;
            text-align: center;
        }
        #progress-bar {
            width: 250px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
            transition: width 0.2s;
        }
        .info-line {
            margin: 5px 0;
        }
        .info-label {
            font-weight: 600;
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div id="progress">
        <div>Loading Gaussian Splatting</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text" style="margin-top: 10px; font-size: 14px;">0%</div>
    </div>
    <div id="info" style="display: none;">
        <div class="info-line"><span class="info-label">Gaussian Splatting Viewer</span></div>
        <div class="info-line">Gaussians: <span id="gaussian-count">-</span></div>
        <div class="info-line">FPS: <span id="fps-counter">-</span></div>
        <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
            Controls: Left click to rotate, Right click to pan, Scroll to zoom
        </div>
    </div>
    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const progressDiv = document.getElementById('progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        const infoDiv = document.getElementById('info');
        const container = document.getElementById('container');
        const gaussianCountSpan = document.getElementById('gaussian-count');
        const fpsCounterSpan = document.getElementById('fps-counter');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // FPS counter
        let lastTime = performance.now();
        let frameCount = 0;

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                fpsCounterSpan.textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Load splat file
        fetch('{{ splat_url }}')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load scene');

                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');
                let receivedLength = 0;
                let chunks = [];

                return reader.read().then(function processResult(result) {
                    if (result.done) {
                        const allChunks = new Uint8Array(receivedLength);
                        let position = 0;
                        for (let chunk of chunks) {
                            allChunks.set(chunk, position);
                            position += chunk.length;
                        }
                        return allChunks;
                    }

                    chunks.push(result.value);
                    receivedLength += result.value.length;

                    if (contentLength) {
                        const percent = Math.round((receivedLength / contentLength) * 100);
                        progressFill.style.width = `${percent}%`;
                        progressText.textContent = `${percent}%`;
                    }

                    return reader.read().then(processResult);
                });
            })
            .then(data => {
                progressText.textContent = 'Processing...';
                return parseSplatData(data);
            })
            .then(splatData => {
                createSplatMesh(splatData);
                progressDiv.style.display = 'none';
                infoDiv.style.display = 'block';
                gaussianCountSpan.textContent = splatData.count.toLocaleString();
            })
            .catch(error => {
                progressDiv.innerHTML = `<div style="color: #ff5555;">Error loading scene</div><div style="font-size: 13px; margin-top: 10px;">${error.message}</div>`;
                console.error('Error loading splat:', error);
            });

        function parseSplatData(data) {
            const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
            const vertexCount = Math.floor(data.length / 44);

            const positions = new Float32Array(vertexCount * 3);
            const colors = new Float32Array(vertexCount * 3);

            for (let i = 0; i < vertexCount; i++) {
                const offset = i * 44;

                // Position
                positions[i * 3] = view.getFloat32(offset, true);
                positions[i * 3 + 1] = view.getFloat32(offset + 4, true);
                positions[i * 3 + 2] = view.getFloat32(offset + 8, true);

                // Color
                colors[i * 3] = view.getUint8(offset + 24) / 255;
                colors[i * 3 + 1] = view.getUint8(offset + 25) / 255;
                colors[i * 3 + 2] = view.getUint8(offset + 26) / 255;
            }

            return { positions, colors, count: vertexCount };
        }

        function createSplatMesh(splatData) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(splatData.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(splatData.colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.02,
                vertexColors: true,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // Center camera
            geometry.computeBoundingSphere();
            if (geometry.boundingSphere) {
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius;
                camera.position.set(center.x, center.y, center.z + radius * 2.5);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateFPS();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
