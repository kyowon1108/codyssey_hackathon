<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gaussian Splatting Viewer - PlayCanvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 18px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 1000;
            max-width: 280px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1000;
            text-align: center;
        }
        #progress-bar {
            width: 250px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
            transition: width 0.2s;
        }
        .info-line {
            margin: 5px 0;
        }
        .info-label {
            font-weight: 600;
            color: #00d4ff;
        }
        #error {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5555;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 40px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1001;
            text-align: center;
            max-width: 400px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Gaussian Splatting</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text" style="margin-top: 10px; font-size: 14px;">0%</div>
    </div>
    <div id="error">
        <div style="font-size: 18px; margin-bottom: 10px;">⚠️ Error Loading Scene</div>
        <div id="error-message"></div>
    </div>
    <div id="info">
        <div class="info-line"><span class="info-label">Gaussian Splatting Viewer</span></div>
        <div class="info-line">Gaussians: <span id="gaussian-count">{{ gaussian_count|default(0)|int }}</span></div>
        {% if psnr or ssim or lpips %}
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="info-line" style="font-size: 12px; color: #00d4ff; margin-bottom: 4px;">Evaluation Metrics</div>
            {% if psnr %}
            <div class="info-line" style="font-size: 11px;">PSNR: <span style="color: #00ff88;">{{ psnr|round(2) }} dB</span></div>
            {% endif %}
            {% if ssim %}
            <div class="info-line" style="font-size: 11px;">SSIM: <span style="color: #00ff88;">{{ ssim|round(4) }}</span></div>
            {% endif %}
            {% if lpips %}
            <div class="info-line" style="font-size: 11px;">LPIPS: <span style="color: #00ff88;">{{ lpips|round(4) }}</span></div>
            {% endif %}
        </div>
        {% endif %}
        <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
            Controls: Left click to rotate, Right click to pan, Scroll to zoom
        </div>
    </div>
    <div id="container"></div>

    <!-- PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>

    <script>
        const loadingDiv = document.getElementById('loading');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        const errorDiv = document.getElementById('error');
        const errorMessage = document.getElementById('error-message');
        const container = document.getElementById('container');

        // PlayCanvas app setup
        const canvas = document.createElement('canvas');
        container.appendChild(canvas);

        const app = new pc.Application(canvas, {
            mouse: new pc.Mouse(canvas),
            touch: new pc.TouchDevice(canvas),
            keyboard: new pc.Keyboard(window)
        });

        // Fill the available space
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        // Resize canvas with window
        window.addEventListener('resize', () => app.resizeCanvas());

        // Create camera entity
        const camera = new pc.Entity('camera');
        camera.addComponent('camera', {
            clearColor: new pc.Color(0, 0, 0)
        });
        camera.setPosition(0, 0, 5);
        app.root.addChild(camera);

        // Add orbit camera script
        camera.addComponent('script');
        camera.script.create('orbitCamera', {
            attributes: {
                inertiaFactor: 0.2,
                distanceMax: 100,
                distanceMin: 0.1,
                pitchAngleMax: 90,
                pitchAngleMin: -90,
                frameOnStart: true
            }
        });

        // Add basic orbit controls
        const OrbitCamera = pc.createScript('orbitCamera');

        OrbitCamera.attributes.add('distanceMax', { type: 'number', default: 100 });
        OrbitCamera.attributes.add('distanceMin', { type: 'number', default: 0.1 });
        OrbitCamera.attributes.add('pitchAngleMax', { type: 'number', default: 90 });
        OrbitCamera.attributes.add('pitchAngleMin', { type: 'number', default: -90 });
        OrbitCamera.attributes.add('inertiaFactor', { type: 'number', default: 0.2 });
        OrbitCamera.attributes.add('frameOnStart', { type: 'boolean', default: true });

        OrbitCamera.prototype.initialize = function() {
            this.eulerAngles = new pc.Vec3();
            this.distance = 5;
            this.targetDistance = this.distance;

            const self = this;
            const onMouseMove = function(event) {
                if (event.buttons[pc.MOUSEBUTTON_LEFT]) {
                    self.eulerAngles.x -= event.dy * 0.3;
                    self.eulerAngles.y -= event.dx * 0.3;
                    self.eulerAngles.x = pc.math.clamp(self.eulerAngles.x, self.pitchAngleMin, self.pitchAngleMax);
                } else if (event.buttons[pc.MOUSEBUTTON_RIGHT]) {
                    const distance = self.distance;
                    self.pivotPoint.x -= (event.dx * distance) / 200;
                    self.pivotPoint.y += (event.dy * distance) / 200;
                }
            };

            const onMouseWheel = function(event) {
                self.targetDistance -= event.wheelDelta * 0.01 * self.targetDistance;
                self.targetDistance = pc.math.clamp(self.targetDistance, self.distanceMin, self.distanceMax);
                event.event.preventDefault();
            };

            this.app.mouse.on(pc.EVENT_MOUSEMOVE, onMouseMove, this);
            this.app.mouse.on(pc.EVENT_MOUSEWHEEL, onMouseWheel, this);

            this.pivotPoint = new pc.Vec3();
            this.targetPivot = new pc.Vec3();

            if (this.frameOnStart) {
                this.frameAllMeshInstances();
            }
        };

        OrbitCamera.prototype.frameAllMeshInstances = function() {
            const meshInstances = [];
            const scene = this.app.scene;

            const processMeshInstances = function(node) {
                if (node.render && node.render.meshInstances) {
                    for (let i = 0; i < node.render.meshInstances.length; i++) {
                        meshInstances.push(node.render.meshInstances[i]);
                    }
                }
                for (let i = 0; i < node.children.length; i++) {
                    processMeshInstances(node.children[i]);
                }
            };

            processMeshInstances(this.app.root);

            if (meshInstances.length === 0) return;

            const bbox = new pc.BoundingBox();
            bbox.copy(meshInstances[0].aabb);

            for (let i = 1; i < meshInstances.length; i++) {
                bbox.add(meshInstances[i].aabb);
            }

            const center = bbox.center;
            const radius = bbox.halfExtents.length();

            this.pivotPoint.copy(center);
            this.targetPivot.copy(center);
            this.distance = radius * 2.5;
            this.targetDistance = this.distance;
        };

        OrbitCamera.prototype.update = function(dt) {
            this.distance = pc.math.lerp(this.distance, this.targetDistance, this.inertiaFactor);
            this.pivotPoint.lerp(this.pivotPoint, this.targetPivot, this.inertiaFactor);

            const quatX = new pc.Quat();
            const quatY = new pc.Quat();

            quatX.setFromAxisAngle(pc.Vec3.RIGHT, this.eulerAngles.x);
            quatY.setFromAxisAngle(pc.Vec3.UP, this.eulerAngles.y);

            const rotation = new pc.Quat();
            rotation.mul2(quatY, quatX);

            const position = new pc.Vec3();
            rotation.transformVector(new pc.Vec3(0, 0, this.distance), position);
            position.add(this.pivotPoint);

            this.entity.setPosition(position);
            this.entity.setRotation(rotation);
            this.entity.lookAt(this.pivotPoint);
        };

        // Create directional light
        const light = new pc.Entity('light');
        light.addComponent('light', {
            type: 'directional',
            color: new pc.Color(1, 1, 1),
            intensity: 1
        });
        light.setEulerAngles(45, 30, 0);
        app.root.addChild(light);

        // Add ambient light
        const ambientLight = new pc.Entity('ambientLight');
        ambientLight.addComponent('light', {
            type: 'directional',
            color: new pc.Color(0.4, 0.4, 0.5),
            intensity: 0.5
        });
        ambientLight.setEulerAngles(-45, 210, 0);
        app.root.addChild(ambientLight);

        // Load PLY file
        const plyUrl = '{{ ply_url }}';

        const assetOptions = {
            filename: 'point_cloud.ply',
            contents: null
        };

        // Fetch PLY file with progress
        fetch(plyUrl)
            .then(response => {
                if (!response.ok) throw new Error('Failed to load PLY file');

                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');
                let receivedLength = 0;
                let chunks = [];

                return reader.read().then(function processResult(result) {
                    if (result.done) {
                        const allChunks = new Uint8Array(receivedLength);
                        let position = 0;
                        for (let chunk of chunks) {
                            allChunks.set(chunk, position);
                            position += chunk.length;
                        }
                        return allChunks;
                    }

                    chunks.push(result.value);
                    receivedLength += result.value.length;

                    if (contentLength) {
                        const percent = Math.round((receivedLength / contentLength) * 100);
                        progressFill.style.width = `${percent}%`;
                        progressText.textContent = `${percent}%`;
                    }

                    return reader.read().then(processResult);
                });
            })
            .then(data => {
                progressText.textContent = 'Processing...';
                assetOptions.contents = data.buffer;

                const asset = new pc.Asset('model.ply', 'container', assetOptions);
                asset.on('load', function() {
                    loadingDiv.style.display = 'none';

                    // Create entity from loaded asset
                    const entity = asset.resource.instantiateRenderEntity();
                    app.root.addChild(entity);

                    // Frame the model in view
                    setTimeout(() => {
                        if (camera.script && camera.script.orbitCamera) {
                            camera.script.orbitCamera.frameAllMeshInstances();
                        }
                    }, 100);
                });

                asset.on('error', function(err) {
                    loadingDiv.style.display = 'none';
                    errorDiv.style.display = 'block';
                    errorMessage.textContent = 'Error processing PLY file: ' + err;
                });

                app.assets.add(asset);
                app.assets.load(asset);
            })
            .catch(error => {
                loadingDiv.style.display = 'none';
                errorDiv.style.display = 'block';
                errorMessage.textContent = error.message;
                console.error('Error loading PLY:', error);
            });

        // Start the app
        app.start();
    </script>
</body>
</html>
