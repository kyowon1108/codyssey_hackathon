<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gaussian Splatting Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        #progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="progress">Loading: 0%</div>
    <div id="info" style="display: none;">
        <strong>Gaussian Splatting Viewer</strong><br>
        Left Mouse: Rotate<br>
        Right Mouse: Pan<br>
        Scroll: Zoom
    </div>
    <div id="container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const progressDiv = document.getElementById('progress');
        const infoDiv = document.getElementById('info');
        const container = document.getElementById('container');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Load splat file
        let iterationCount = 'unknown';
        fetch('SPLAT_URL_PLACEHOLDER')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load scene');

                // Get iteration count from header
                iterationCount = response.headers.get('X-Iteration') || 'unknown';

                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');
                let receivedLength = 0;
                let chunks = [];

                return reader.read().then(function processResult(result) {
                    if (result.done) {
                        const allChunks = new Uint8Array(receivedLength);
                        let position = 0;
                        for (let chunk of chunks) {
                            allChunks.set(chunk, position);
                            position += chunk.length;
                        }
                        return allChunks;
                    }

                    chunks.push(result.value);
                    receivedLength += result.value.length;

                    if (contentLength) {
                        const percent = Math.round((receivedLength / contentLength) * 100);
                        progressDiv.textContent = `Loading: ${percent}%`;
                    }

                    return reader.read().then(processResult);
                });
            })
            .then(data => {
                progressDiv.textContent = 'Processing...';
                return parseSplatData(data);
            })
            .then(splatData => {
                createSplatMesh(splatData);
                progressDiv.style.display = 'none';
                infoDiv.style.display = 'block';
            })
            .catch(error => {
                progressDiv.textContent = `Error: ${error.message}`;
                console.error('Error loading splat:', error);
            });

        function parseSplatData(data) {
            const view = new DataView(data.buffer);
            const vertexCount = data.length / 44; // Each splat is 44 bytes

            const positions = new Float32Array(vertexCount * 3);
            const colors = new Float32Array(vertexCount * 3);

            for (let i = 0; i < vertexCount; i++) {
                const offset = i * 44;

                // Position (3 floats)
                positions[i * 3] = view.getFloat32(offset, true);
                positions[i * 3 + 1] = view.getFloat32(offset + 4, true);
                positions[i * 3 + 2] = view.getFloat32(offset + 8, true);

                // Skip scale (3 floats = 12 bytes)

                // Color (4 bytes: R, G, B, opacity)
                colors[i * 3] = view.getUint8(offset + 24) / 255;
                colors[i * 3 + 1] = view.getUint8(offset + 25) / 255;
                colors[i * 3 + 2] = view.getUint8(offset + 26) / 255;
            }

            return { positions, colors, count: vertexCount };
        }

        function createSplatMesh(splatData) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(splatData.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(splatData.colors, 3));
            geometry.computeBoundingSphere();

            const material = new THREE.PointsMaterial({
                size: 0.025,
                vertexColors: true,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // Center camera
            if (geometry.boundingSphere) {
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius;
                camera.position.set(center.x, center.y, center.z + radius * 2);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
            }

            infoDiv.innerHTML = `<strong>Gaussian Splatting Viewer</strong><br>
                Iteration: ${iterationCount.toLocaleString()}<br>
                Gaussians: ${splatData.count.toLocaleString()}<br>
                Left Mouse: Rotate<br>
                Right Mouse: Pan<br>
                Scroll: Zoom`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
